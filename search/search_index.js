var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SpinPlots","text":"<p>Welcome to the documentation for <code>SpinPlots</code>! This Python package is designed to simplify the process of reading and plotting NMR data. While NMRglue is a powerful library for reading, processing, and analyzing NMR data, creating basic plots often requires a lot of code. <code>SpinPlots</code> streamlines these tasks, allowing you to produce clean, publication-ready plots with minimal effort.</p> <p>For example, to generate a simple 1D NMR plot using NMRglue, you would typically write the following:</p> <pre><code># Import python libraries\nimport nmrglue as ng\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Read Bruker's processed data\ndic, data = ng.bruker.read_pdata(\"Data/1/pdata/1/\")\n\n# Get universal dic\nudic = ng.bruker.guess_udic(dic, data)\n\n# Create a unit conversion object for the axis\nuc = ng.fileiobase.uc_from_udic(udic)\n\n# Get ppm scale\nppm_scale = uc.ppm_scale()\n\n# Plot the spectrum\nplt.plot(ppm_scale, data, label=\"Sample X\")\nplt.xlim(20, 0)\nplt.xlabel(\"$^1$H (ppm)\")\nplt.ylabel(\"Intensity (a.u.)\")\nplt.legend()\n\n# Save the figure\nfig.savefig(\"spectrum.png\")\n</code></pre> <p>This is a lot of code for a simple 1D plot! If one wants to make a 2D plot with projections things become even harder</p> <p><code>SpinPlots</code> tries to simplify the process. With just one function call, you can create the same 1D plot:</p> <pre><code>from spinplots.plot import bruker1d\n\nbruker1d(\n    [\"Data/1/pdata/1/\"],\n    labels=[\"Sample X\"],\n    xlim=(20, 0),\n    save=True,\n    filename=\"spectrum\",\n    format=\"png\",\n)\n</code></pre>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Terminal functionality: Added <code>bruker2csv</code> to convert NMR data into CSV from the terminal.</li> <li>Plotting functions: Added the following functions to streamline plotting:<ul> <li><code>bruker1d</code> for generating 1D NMR plots</li> <li><code>bruker1d_grid</code> for generating subplots</li> <li><code>bruker2d</code> for generating 2D NMR plots</li> </ul> </li> <li>NMR dataframe: Added the <code>nmr_df</code> function to create a Pandas DataFrame from NMR data, for further data manipulation, analysis and plotting.</li> <li>Tutorials:<ul> <li>Creating 1D and 2D plots using the spinplots functions.</li> <li>Obtain a Pandas DataFrame from NMR data for custom plot styling and manipulation.</li> </ul> </li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/contributors.html","title":"People","text":"<p>SpinPlots was originally written and is actively maintained by</p> <ul> <li> <p>Carlos Bornes</p> </li> <li> <p>Daniel Pereira</p> </li> <li> <p>M\u00e1rcio Soares</p> </li> </ul>"},{"location":"about/contributors.html#contributorscontributions","title":"Contributors/Contributions","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Some project that served as inspiration for SpinPlots are:</p> <ul> <li> <p>Quantum Accelerators Python package template created by Andrew S. Rosen</p> </li> <li> <p>NMRglue by Jonathan J. Helmus for providing Python function for reading, processing NMR data</p> </li> <li> <p>Our own frustration trying to remember NMRglue's syntax and using Bruker's TopSpin for producing plots for papers. \ud83e\udd2a</p> </li> </ul>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can easily install Spinplots with the following command:</p> <pre><code>pip install git+https://github.com/carlosbornes/spinplots\n</code></pre> <p>All dependecies <code>pyproject.toml</code> file are installed automatically.</p> <p>To verify that the package has been installed successfully, open a Python console and run:</p> <pre><code>import spinplots\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>spinplots<ul> <li>cli</li> <li>plot</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/spinplots/cli.html","title":"cli","text":""},{"location":"reference/spinplots/cli.html#spinplots.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Convert Bruker's NMR data to csv files on the terminal</p> Source code in <code>spinplots/cli.py</code> <pre><code>def main():\n    \"\"\"\n    Convert Bruker's NMR data to csv files on the terminal\n    \"\"\"\n    if len(sys.argv) != 3:\n        logging.error(\"Incorrect number of arguments provided.\")\n        logging.error(\"Usage: bruker2csv &lt;path_to_data&gt; &lt;path_to_output&gt;\")\n\n        sys.exit(1)\n\n    data_path = sys.argv[1]\n    output_path = sys.argv[2]\n\n    try:\n        df_nmr = nmr_df(data_path)\n        if df_nmr.attrs.get(\"nmr_dim\") == 2:\n            df_nmr.to_csv(output_path, index=True)\n            logging.info(f\"Data written to {output_path}\")\n        elif df_nmr.attrs.get(\"nmr_dim\") == 1:\n            df_nmr.to_csv(output_path, index=False)\n            logging.info(f\"Data written to {output_path}\")\n    except Exception as e:\n        logging.error(f\"An error occurred: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/spinplots/plot.html","title":"plot","text":""},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d","title":"bruker1d","text":"<pre><code>bruker1d(data_paths, labels=None, labelsize=None, xlim=None, save=False, filename=None, format=None, frame=False, normalized=False, stacked=False, color=None, return_fig=False, background_paths=None, background_factors=None, linewidth=None, linestyle=None, alpha=None, yaxislabel=None, xaxislabel=None, axisfontsize=None, axisfont=None, tickfontsize=None, tickfont=None, tickspacing=None)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data.</p> <p>Parameters:     data_paths (str/list): Path or list of paths to the Bruker data directories.</p> <p>Keyword arguments:     labels (list): List of labels for the spectra.     labelsize (float): Font size for the labels.     xlim (tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     stacked (bool): Whether to stack the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.     background_paths (list): List of paths to the Bruker background data directories.     background_factors (list): List of factors to multiply the background by.     linewidth (float): Line width of the plot.     linestyle (str): Style of the plot lines.     alpha (float): Transparency of the plot lines.     xaxislabel (str): Label for the axis.     yaxislabel (str): Label for the y-axis.     axisfont (str): Font type for the axis label.     axisfontsize (int): Font size for the axis label.     tickfont (str): Font type for the tick labels.     tickfontsize (int): Font size for the tick labels.     tickspacing (int): Spacing between the tick labels.</p> <p>Example:     bruker1d(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], xlim=(0, 100), save=True, filename='1d_spectra', format='png', frame=False, normalized=True, stacked=True, color=['red', 'blue'])</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d(\n    data_paths,\n    labels=None,\n    labelsize=None,\n    xlim=None,\n    save=False,\n    filename=None,\n    format=None,\n    frame=False,\n    normalized=False,\n    stacked=False,\n    color=None,\n    return_fig=False,\n    background_paths=None,\n    background_factors=None,\n    linewidth=None,\n    linestyle=None,\n    alpha=None,\n    yaxislabel=None,\n    xaxislabel=None,\n    axisfontsize=None,\n    axisfont=None,\n    tickfontsize=None,\n    tickfont=None,\n    tickspacing=None,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data.\n\n    Parameters:\n        data_paths (str/list): Path or list of paths to the Bruker data directories.\n\n    Keyword arguments:\n        labels (list): List of labels for the spectra.\n        labelsize (float): Font size for the labels.\n        xlim (tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        stacked (bool): Whether to stack the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n        background_paths (list): List of paths to the Bruker background data directories.\n        background_factors (list): List of factors to multiply the background by.\n        linewidth (float): Line width of the plot.\n        linestyle (str): Style of the plot lines.\n        alpha (float): Transparency of the plot lines.\n        xaxislabel (str): Label for the axis.\n        yaxislabel (str): Label for the y-axis.\n        axisfont (str): Font type for the axis label.\n        axisfontsize (int): Font size for the axis label.\n        tickfont (str): Font type for the tick labels.\n        tickfontsize (int): Font size for the tick labels.\n        tickspacing (int): Spacing between the tick labels.\n\n    Example:\n        bruker1d(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], xlim=(0, 100), save=True, filename='1d_spectra', format='png', frame=False, normalized=True, stacked=True, color=['red', 'blue'])\n    \"\"\"\n    fig, ax = plt.subplots()\n\n    nucleus_set = set()\n\n    # Convert string to list for consistency\n    if isinstance(data_paths, str):\n        data_paths = [data_paths]\n\n    # Default values to be updated if provided\n    defaults = {\n        \"labelsize\": 12,\n        \"linewidth\": 1.0,\n        \"linestyle\": \"-\",\n        \"alpha\": 1.0,\n        \"axisfontsize\": 13,\n        \"axisfont\": None,\n        \"tickfontsize\": 12,\n        \"tickfont\": None,\n        \"yaxislabel\": \"Intensity (a.u.)\",\n        \"xaxislabel\": None,\n        \"tickspacing\": None,\n    }\n\n    params = {k: v for k, v in locals().items() if k in defaults and v is not None}\n    defaults.update(params)\n\n    prev_max = 0\n    for i, data_path in enumerate(data_paths):\n        dic, data = ng.bruker.read_pdata(data_path)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        nuclei = udic[0][\"label\"]\n\n        # Extract the number and nucleus symbol from the label\n        number, nucleus = (\n            \"\".join(filter(str.isdigit, nuclei)),\n            \"\".join(filter(str.isalpha, nuclei)),\n        )\n\n        # Check if the same nucleus is being used\n        nucleus_set.add(nucleus)\n        if len(nucleus_set) &gt; 1:\n            raise ValueError(\"All the spectra must be of the same nucleus.\")\n\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n\n        # Normalize the spectrum\n        if normalized == \"max\" or normalized:\n            data = data / np.amax(data)\n        elif normalized == \"scans\":\n            ns = dic[\"acqus\"][\"NS\"]\n            if ns is None:\n                raise ValueError(\"Number of scans not found.\")\n            data = data / ns\n        elif normalized:\n            raise ValueError(\n                \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n            )\n\n        # Remove background\n        if background_paths is not None:\n            if background_factors is None:\n                raise ValueError(\"Background factors must be provided.\")\n            if i &gt;= len(background_paths):\n                raise ValueError(\n                    \"Number of background paths must be equal to the number of spectra.\"\n                )\n\n            background_path = background_paths[i]\n            background_factor = background_factors[i]\n            dic_bg, data_bg = ng.bruker.read_pdata(background_path)\n            udic_bg = ng.bruker.guess_udic(dic_bg, data_bg)\n\n            uc_bg = ng.fileiobase.uc_from_udic(udic_bg, dim=0)\n            ppm_bg = uc_bg.ppm_scale()\n\n            if ppm.shape != ppm_bg.shape:\n                raise ValueError(\n                    \"Data and background spectra must have the same dimensions.\"\n                )\n\n            # Normalize the background\n            if normalized == \"max\" or normalized:\n                data_bg = data_bg / np.amax(data_bg)\n            elif normalized == \"scans\":\n                ns_bg = dic_bg[\"acqus\"][\"NS\"]\n                if ns_bg is None:\n                    raise ValueError(\"Number of scans not found.\")\n                data_bg = data_bg / ns_bg\n            elif normalized:\n                raise ValueError(\n                    \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n                )\n\n            # Remove the background\n            data = data - background_factor * data_bg\n\n        # Stack the spectra\n        if stacked:\n            data += i * 1.1 if normalized else prev_max\n\n        # Plot the spectrum\n        if labels and color:\n            ax.plot(\n                ppm,\n                data,\n                label=labels[i],\n                color=color[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n            ax.legend(\n                bbox_to_anchor=(1.05, 1),\n                loc=\"upper left\",\n                fontsize=defaults[\"labelsize\"],\n                prop={\n                    \"family\": defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n                    \"size\": defaults[\"labelsize\"],\n                },\n            )\n        elif labels:\n            ax.plot(\n                ppm,\n                data,\n                label=labels[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n            ax.legend(\n                bbox_to_anchor=(1.05, 1),\n                loc=\"upper left\",\n                prop={\n                    \"family\": defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n                    \"size\": defaults[\"labelsize\"],\n                },\n            )\n        elif color:\n            ax.plot(\n                ppm,\n                data,\n                color=color[i],\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n        else:\n            ax.plot(\n                ppm,\n                data,\n                linestyle=defaults[\"linestyle\"],\n                linewidth=defaults[\"linewidth\"],\n                alpha=defaults[\"alpha\"],\n            )\n\n        prev_max = np.amax(data)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters\n    if xaxislabel:\n        ax.set_xlabel(\n            xaxislabel,\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n    else:\n        ax.set_xlabel(\n            f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\",\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n    ax.tick_params(\n        axis=\"x\",\n        labelsize=defaults[\"tickfontsize\"],\n        labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n    )\n\n    if defaults[\"tickspacing\"]:\n        ax.xaxis.set_major_locator(plt.MultipleLocator(defaults[\"tickspacing\"]))\n\n    # Remove frame\n    if not frame:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_yticklabels([])\n        ax.set_yticks([])\n    else:\n        ax.set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax.tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n\n    # Set axis limits if provided\n    if xlim:\n        ax.set_xlim(xlim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n    if return_fig:\n        return fig, ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d_background","title":"bruker1d_background","text":"<pre><code>bruker1d_background(data_path, background_path, background_factor, labels=None, xlim=None, save=False, filename=None, format=None, frame=False, normalized=False, color=None, return_fig=False)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data with background removal.</p> <p>Parameters:     data_path (str): Path to the Bruker data directory.     background_path (str): Path to the Bruker background data directory.     background_factor (float): Factor to multiply the background by.</p> <p>Keyword arguments:     labels (list): List of labels for the spectra.     xlim (tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d_background(\n    data_path,\n    background_path,\n    background_factor,\n    labels=None,\n    xlim=None,\n    save=False,\n    filename=None,\n    format=None,\n    frame=False,\n    normalized=False,\n    color=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data with background removal.\n\n    Parameters:\n        data_path (str): Path to the Bruker data directory.\n        background_path (str): Path to the Bruker background data directory.\n        background_factor (float): Factor to multiply the background by.\n\n    Keyword arguments:\n        labels (list): List of labels for the spectra.\n        xlim (tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n    \"\"\"\n\n    fig, ax = plt.subplots()\n\n    dic, data = ng.bruker.read_pdata(data_path)\n    udic = ng.bruker.guess_udic(dic, data)\n\n    nuclei = udic[0][\"label\"]\n\n    # Extract the number and nucleus symbol from the label\n    number, nucleus = (\n        \"\".join(filter(str.isdigit, nuclei)),\n        \"\".join(filter(str.isalpha, nuclei)),\n    )\n\n    uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n    ppm = uc.ppm_scale()\n\n    # Normalize the spectrum\n    if normalized == \"max\" or normalized:\n        data = data / np.amax(data)\n    elif normalized == \"scans\":\n        ns = dic[\"acqus\"][\"NS\"]\n        if ns is None:\n            raise ValueError(\"Number of scans not found.\")\n        data = data / ns\n    elif normalized:\n        raise ValueError(\n            \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n        )\n\n    # Read the background data\n    dic_bg, data_bg = ng.bruker.read_pdata(background_path)\n    udic_bg = ng.bruker.guess_udic(dic_bg, data_bg)\n\n    uc_bg = ng.fileiobase.uc_from_udic(udic_bg, dim=0)\n    ppm_bg = uc_bg.ppm_scale()\n\n    if ppm.shape != ppm_bg.shape:\n        raise ValueError(\"Data and background spectra must have the same dimensions.\")\n\n    # Normalize the background\n    if normalized == \"max\" or normalized:\n        data_bg = data_bg / np.amax(data_bg)\n    elif normalized == \"scans\":\n        ns_bg = dic_bg[\"acqus\"][\"NS\"]\n        if ns_bg is None:\n            raise ValueError(\"Number of scans not found.\")\n        data_bg = data_bg / ns_bg\n    elif normalized:\n        raise ValueError(\n            \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n        )\n\n    # Remove the background\n    data = data - background_factor * data_bg\n\n    # Plot the spectrum\n    if labels is not None and color is not None:\n        ax.plot(ppm, data, label=labels, color=color)\n        ax.legend()\n    elif labels is not None:\n        ax.plot(ppm, data, label=labels)\n        ax.legend()\n    elif color is not None:\n        ax.plot(ppm, data, color=color)\n    else:\n        ax.plot(ppm, data)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters\n    ax.set_xlabel(f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\", fontsize=13)\n    ax.tick_params(axis=\"x\", labelsize=12)\n\n    # Remove frame\n    if not frame:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_yticklabels([])\n        ax.set_yticks([])\n    else:\n        ax.set_ylabel(\"Intensity (a.u.)\", fontsize=13)\n        ax.tick_params(axis=\"y\", labelsize=12)\n\n    # Set axis limits if provided\n    if xlim:\n        ax.set_xlim(xlim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return fig, ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker1d_grid","title":"bruker1d_grid","text":"<pre><code>bruker1d_grid(data_paths, labels=None, subplot_dims=(1, 1), xlim=None, save=False, filename=None, format='png', frame=False, normalized=False, color=None, return_fig=False)\n</code></pre> <p>Plots 1D NMR spectra from Bruker data in subplots.</p> <p>Parameters:     data_paths (list): List of paths to the Bruker data directories.     labels (list): List of labels for the spectra.     subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).     xlim (list of tuples or tuple): The limits for the x-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     frame (bool): Whether to show the frame.     normalized (bool): Whether to normalize the spectra.     color (str): List of colors for the spectra.     return_fig (bool): Whether to return the figure and axis.</p> <p>Example:     bruker1d_grid(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalized=True, color=['red', 'blue'])</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker1d_grid(\n    data_paths,\n    labels=None,\n    subplot_dims=(1, 1),\n    xlim=None,\n    save=False,\n    filename=None,\n    format=\"png\",\n    frame=False,\n    normalized=False,\n    color=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plots 1D NMR spectra from Bruker data in subplots.\n\n    Parameters:\n        data_paths (list): List of paths to the Bruker data directories.\n        labels (list): List of labels for the spectra.\n        subplot_dims (tuple): Dimensions of the subplot grid (rows, cols).\n        xlim (list of tuples or tuple): The limits for the x-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        frame (bool): Whether to show the frame.\n        normalized (bool): Whether to normalize the spectra.\n        color (str): List of colors for the spectra.\n        return_fig (bool): Whether to return the figure and axis.\n\n    Example:\n        bruker1d_grid(['data/1d_data1', 'data/1d_data2'], labels=['Spectrum 1', 'Spectrum 2'], subplot_dims=(1, 2), xlim=[(0, 100), (0, 100)], save=True, filename='1d_spectra', format='png', frame=False, normalized=True, color=['red', 'blue'])\n    \"\"\"\n    rows, cols = subplot_dims\n    fig, axes = plt.subplots(rows, cols, figsize=(5 * cols, 4 * rows))\n    axes = axes.flatten() if rows * cols &gt; 1 else [axes]\n\n    for i, data_path in enumerate(data_paths):\n        if i &gt;= len(axes):\n            break\n        ax = axes[i]\n        dic, data = ng.bruker.read_pdata(data_path)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        nuclei = udic[0][\"label\"]\n        number, nucleus = (\n            \"\".join(filter(str.isdigit, nuclei)),\n            \"\".join(filter(str.isalpha, nuclei)),\n        )\n\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n\n        # Check if normalized is a list or a single value\n        if isinstance(normalized, list):\n            if len(normalized) != len(data_paths):\n                raise ValueError(\n                    \"The length of the normalized list must be equal to the number of spectra.\"\n                )\n            normalized = normalized[i]\n\n        if normalized == \"max\" or normalized:\n            data = data / np.amax(data)\n        elif normalized == \"scans\":\n            ns = dic[\"acqus\"][\"NS\"]\n            if ns is None:\n                raise ValueError(\"Number of scans not found.\")\n            data = data / ns\n        elif normalized:\n            raise ValueError(\n                \"Invalid value for normalized. Please provide 'max' or 'scans'.\"\n            )\n\n        if labels and color:\n            ax.plot(ppm, data, label=labels[i], color=color[i])\n            ax.legend()\n        elif labels:\n            ax.plot(ppm, data, label=labels[i])\n            ax.legend()\n        elif color:\n            ax.plot(ppm, data, color=color[i])\n        else:\n            ax.plot(ppm, data)\n\n        ax.set_xlabel(f\"$^{{{number}}}\\\\mathrm{{{nucleus}}}$ (ppm)\", fontsize=13)\n        ax.tick_params(axis=\"x\", labelsize=12)\n\n        if not frame:\n            ax.spines[\"top\"].set_visible(False)\n            ax.spines[\"right\"].set_visible(False)\n            ax.spines[\"left\"].set_visible(False)\n            ax.set_yticklabels([])\n            ax.set_yticks([])\n        else:\n            ax.set_ylabel(\"Intensity (a.u.)\", fontsize=13)\n            ax.tick_params(axis=\"y\", labelsize=12)\n\n        if xlim and isinstance(xlim, tuple):\n            ax.set_xlim(xlim)\n        elif xlim and isinstance(xlim, list):\n            ax.set_xlim(xlim[i])\n\n    plt.tight_layout()\n\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"1d_nmr_spectra.\" + format\n        fig.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return fig, axes\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.bruker2d","title":"bruker2d","text":"<pre><code>bruker2d(data_path, contour_start, contour_num, contour_factor, cmap=None, colors=None, xlim=None, ylim=None, save=False, filename=None, format=None, diag=None, homo=False, return_fig=False, linewidth_contour=None, linewidth_proj=None, xaxislabel=None, yaxislabel=None, axisfont=None, axisfontsize=None, tickfont=None, tickfontsize=None, tickspacing=None)\n</code></pre> <p>Plots a 2D NMR spectrum from Bruker data.</p> <p>Parameters:     data_path (str or list): Path or list of paths to the Bruker data directories.     contour_start (float or list): Start value for the contour levels.     contour_num (int or list): Number of list of contour levels.     contour_factor (float or list): Factor or list of factors by which the contour levels increase.</p> <p>Keyword arguments:     cmap (str or list): Colormap(s) to use for the contour lines.     colors (list): Colors to use when overlaying spectra.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     diag (float or None): Slope of the diagonal line/None.     homo (bool): True if doing homonuclear experiment.     return_fig (bool): Whether to return the figure and axis.     linewidth_contour (float): Line width of the contour plot.     linewidth_proj (float): Line width of the projections.     xaxislabel (str): Label for the axis.     yaxislabel (str): Label for the y-axis.     axisfont (str): Font type for the axis label.     axisfontsize (int): Font size for the axis label.     tickfont (str): Font type for the tick labels.     tickfontsize (int): Font size for the tick labels.     tickspacing (int): Spacing between the tick labels.</p> <p>Example:     bruker2d('data/2d_data', 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)</p> Source code in <code>spinplots/plot.py</code> <pre><code>def bruker2d(\n    data_path,\n    contour_start,\n    contour_num,\n    contour_factor,\n    cmap=None,\n    colors=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    diag=None,\n    homo=False,\n    return_fig=False,\n    linewidth_contour=None,\n    linewidth_proj=None,\n    xaxislabel=None,\n    yaxislabel=None,\n    axisfont=None,\n    axisfontsize=None,\n    tickfont=None,\n    tickfontsize=None,\n    tickspacing=None,\n):\n    \"\"\"\n    Plots a 2D NMR spectrum from Bruker data.\n\n    Parameters:\n        data_path (str or list): Path or list of paths to the Bruker data directories.\n        contour_start (float or list): Start value for the contour levels.\n        contour_num (int or list): Number of list of contour levels.\n        contour_factor (float or list): Factor or list of factors by which the contour levels increase.\n\n    Keyword arguments:\n        cmap (str or list): Colormap(s) to use for the contour lines.\n        colors (list): Colors to use when overlaying spectra.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        diag (float or None): Slope of the diagonal line/None.\n        homo (bool): True if doing homonuclear experiment.\n        return_fig (bool): Whether to return the figure and axis.\n        linewidth_contour (float): Line width of the contour plot.\n        linewidth_proj (float): Line width of the projections.\n        xaxislabel (str): Label for the axis.\n        yaxislabel (str): Label for the y-axis.\n        axisfont (str): Font type for the axis label.\n        axisfontsize (int): Font size for the axis label.\n        tickfont (str): Font type for the tick labels.\n        tickfontsize (int): Font size for the tick labels.\n        tickspacing (int): Spacing between the tick labels.\n\n    Example:\n        bruker2d('data/2d_data', 0.1, 10, 1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png', diag=True)\n    \"\"\"\n\n    defaults = {\n        \"linewidth_contour\": 0.5,\n        \"linewidth_proj\": 0.8,\n        \"xaxislabel\": None,\n        \"yaxislabel\": None,\n        \"axisfont\": None,\n        \"axisfontsize\": 13,\n        \"tickfont\": None,\n        \"tickfontsize\": 12,\n        \"tickspacing\": None,\n    }\n\n    params = {k: v for k, v in locals().items() if k in defaults and v is not None}\n    defaults.update(params)\n\n    if isinstance(data_path, str):\n        data_path = [data_path]\n\n    # Create figure and axis\n    fig = plt.figure(constrained_layout=False)\n    ax = fig.subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    for i, nmr in enumerate(data_path):\n        dic, data = ng.bruker.read_pdata(nmr)\n        udic = ng.bruker.guess_udic(dic, data)\n\n        # Check if homo is set to True\n        if homo:\n            nuclei_x = udic[1][\"label\"]\n            nuclei_y = udic[1][\"label\"]\n        else:\n            nuclei_x = udic[1][\"label\"]\n            nuclei_y = udic[0][\"label\"]\n\n        # Extract the number and nucleus symbol from the label\n        number_x, nucleus_x = (\n            \"\".join(filter(str.isdigit, nuclei_x)),\n            \"\".join(filter(str.isalpha, nuclei_x)),\n        )\n        number_y, nucleus_y = (\n            \"\".join(filter(str.isdigit, nuclei_y)),\n            \"\".join(filter(str.isalpha, nuclei_y)),\n        )\n\n        uc_x = ng.fileiobase.uc_from_udic(udic, dim=1)\n        ppm_x = uc_x.ppm_scale()\n        ppm_x_limits = uc_x.ppm_limits()\n\n        uc_y = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm_y = uc_y.ppm_scale()\n        ppm_y_limits = uc_y.ppm_limits()\n\n        # Get indices for the zoomed region if limits are specified\n        if xlim:\n            x_min_idx = np.abs(ppm_x - max(xlim)).argmin()\n            x_max_idx = np.abs(ppm_x - min(xlim)).argmin()\n            x_indices = slice(min(x_min_idx, x_max_idx), max(x_min_idx, x_max_idx))\n        else:\n            x_indices = slice(None)\n\n        if ylim:\n            y_min_idx = np.abs(ppm_y - max(ylim)).argmin()\n            y_max_idx = np.abs(ppm_y - min(ylim)).argmin()\n            y_indices = slice(min(y_min_idx, y_max_idx), max(y_min_idx, y_max_idx))\n        else:\n            y_indices = slice(None)\n\n        # Calculate projections based on the zoomed region\n        zoomed_data = data[y_indices, x_indices]\n        proj_x = np.amax(zoomed_data, axis=0)\n        proj_y = np.amax(zoomed_data, axis=1)\n\n        # Contour levels\n        contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n        # Plot projections with the extracted color\n        # using the relevant portions of x and y ranges\n        x_proj_ppm = ppm_x[x_indices]\n        y_proj_ppm = ppm_y[y_indices]\n\n        # Plot contour lines with the provided colormap if cmap is provided\n        if cmap is not None:\n            from matplotlib.colors import LogNorm\n\n            if isinstance(cmap, str):\n                cmap = [cmap]\n                if len(cmap) &gt; 1:\n                    warnings.warn(\n                        \"Warning: Consider using colors instead of cmap\"\n                        \"when overlapping spectra.\"\n                    )\n\n            cmap_i = plt.get_cmap(cmap[i])\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                cmap=cmap[i],\n                linewidths=defaults[\"linewidth_contour\"],\n                norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n            )\n            darkest_color = cmap_i(\n                mcolors.Normalize(vmin=contour_levels.min(), vmax=contour_levels.max())(\n                    contour_levels[0]\n                )\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n        elif cmap is not None and colors is not None:\n            # Error. Only one of cmap or colors can be provided.\n            raise ValueError(\"Only one of cmap or colors can be provided.\")\n        elif colors is not None and cmap is None:\n            darkest_color = colors[i]\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                colors=darkest_color,\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n        else:\n            darkest_color = \"black\"\n            contour_plot = ax[\"A\"].contour(\n                data,\n                contour_levels,\n                extent=(\n                    ppm_x_limits[0],\n                    ppm_x_limits[1],\n                    ppm_y_limits[0],\n                    ppm_y_limits[1],\n                ),\n                colors=\"black\",\n                linewidths=defaults[\"linewidth_contour\"],\n            )\n            ax[\"a\"].plot(\n                x_proj_ppm,\n                proj_x,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"a\"].axis(False)\n            ax[\"b\"].plot(\n                -proj_y,\n                y_proj_ppm,\n                linewidth=defaults[\"linewidth_proj\"],\n                color=darkest_color,\n            )\n            ax[\"b\"].axis(False)\n\n        if xaxislabel:\n            defaults[\"xaxislabel\"] = xaxislabel\n        else:\n            defaults[\"xaxislabel\"] = f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\"\n        if yaxislabel:\n            defaults[\"yaxislabel\"] = yaxislabel\n        else:\n            defaults[\"yaxislabel\"] = f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\"\n\n        ax[\"A\"].set_xlabel(\n            defaults[\"xaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].set_ylabel(\n            defaults[\"yaxislabel\"],\n            fontsize=defaults[\"axisfontsize\"],\n            fontname=defaults[\"axisfont\"] if defaults[\"axisfont\"] else None,\n        )\n        ax[\"A\"].yaxis.set_label_position(\"right\")\n        ax[\"A\"].yaxis.tick_right()\n        ax[\"A\"].tick_params(\n            axis=\"x\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n        ax[\"A\"].tick_params(\n            axis=\"y\",\n            labelsize=defaults[\"tickfontsize\"],\n            labelfontfamily=defaults[\"tickfont\"] if defaults[\"tickfont\"] else None,\n        )\n\n        # Plot diagonal line if diag is provided\n        if diag is not None:\n            x_diag = np.linspace(ppm_x_limits[0], ppm_x_limits[1], 100)\n            y_diag = diag * x_diag\n            ax[\"A\"].plot(x_diag, y_diag, linestyle=\"--\", color=\"gray\")\n\n        # Set axis limits if provided\n        if xlim:\n            ax[\"A\"].set_xlim(xlim)\n            ax[\"a\"].set_xlim(xlim)\n        if ylim:\n            ax[\"A\"].set_ylim(ylim)\n            ax[\"b\"].set_ylim(ylim)\n\n    # Show the plot or save it\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"2d_nmr_spectrum.\" + format\n        plt.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n\n    if return_fig:\n        return ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/plot.html#spinplots.plot.df2d","title":"df2d","text":"<pre><code>df2d(path, contour_start, contour_num, contour_factor, cmap=None, xlim=None, ylim=None, save=False, filename=None, format=None, return_fig=False)\n</code></pre> <p>Plot 2D NMR data from a CSV file or a DataFrame.</p> <p>Parameters: path (str): Path to the CSV file. contour_start (float): Contour start value. contour_num (int): Number of contour levels. contour_factor (float): Contour factor.</p> <p>Keyword arguments:     cmap (str): The colormap to use for the contour lines.     xlim (tuple): The limits for the x-axis.     ylim (tuple): The limits for the y-axis.     save (bool): Whether to save the plot.     filename (str): The name of the file to save the plot.     format (str): The format to save the file in.     return_fig (bool): Whether to return the figure and axis.</p> <p>Example: df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')</p> Source code in <code>spinplots/plot.py</code> <pre><code>def df2d(\n    path,\n    contour_start,\n    contour_num,\n    contour_factor,\n    cmap=None,\n    xlim=None,\n    ylim=None,\n    save=False,\n    filename=None,\n    format=None,\n    return_fig=False,\n):\n    \"\"\"\n    Plot 2D NMR data from a CSV file or a DataFrame.\n\n    Parameters:\n    path (str): Path to the CSV file.\n    contour_start (float): Contour start value.\n    contour_num (int): Number of contour levels.\n    contour_factor (float): Contour factor.\n\n    Keyword arguments:\n        cmap (str): The colormap to use for the contour lines.\n        xlim (tuple): The limits for the x-axis.\n        ylim (tuple): The limits for the y-axis.\n        save (bool): Whether to save the plot.\n        filename (str): The name of the file to save the plot.\n        format (str): The format to save the file in.\n        return_fig (bool): Whether to return the figure and axis.\n\n    Example:\n    df2d('nmr_data.csv', contour_start=4e3, contour_num=10, contour_factor=1.2, cmap='viridis', xlim=(0, 100), ylim=(0, 100), save=True, filename='2d_spectrum', format='png')\n    \"\"\"\n\n    # Check if path to CSV or DataFrame\n    df_nmr = path if isinstance(path, pd.DataFrame) else pd.read_csv(path)\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    number_x, nucleus_x = (\n        \"\".join(filter(str.isdigit, f1_nuclei)),\n        \"\".join(filter(str.isalpha, f1_nuclei)),\n    )\n    f2_nuclei, f2_units = cols[1].split()\n    number_y, nucleus_y = (\n        \"\".join(filter(str.isdigit, f2_nuclei)),\n        \"\".join(filter(str.isalpha, f2_nuclei)),\n    )\n    data_grid = df_nmr.pivot_table(index=cols[0], columns=cols[1], values=\"intensity\")\n    proj_f1, proj_f2 = calculate_projections(df_nmr, export=False)\n\n    f1 = data_grid.index.to_numpy()\n    f2 = data_grid.columns.to_numpy()\n    x, y = np.meshgrid(f2, f1)\n    z = data_grid.to_numpy()\n\n    contour_levels = contour_start * contour_factor ** np.arange(contour_num)\n\n    ax = plt.figure(constrained_layout=False).subplot_mosaic(\n        \"\"\"\n    .a\n    bA\n    \"\"\",\n        gridspec_kw={\n            \"height_ratios\": [0.9, 6.0],\n            \"width_ratios\": [0.8, 6.0],\n            \"wspace\": 0.03,\n            \"hspace\": 0.04,\n        },\n    )\n\n    if cmap is not None:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=cmap,\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n    else:\n        ax[\"A\"].contourf(\n            x,\n            y,\n            z,\n            contour_levels,\n            cmap=\"Greys\",\n            norm=LogNorm(vmin=contour_levels[0], vmax=contour_levels[-1]),\n        )\n\n    # Plot projections with the extracted color\n    ax[\"a\"].plot(\n        proj_f2[f\"{f2_nuclei} {f2_units}\"], proj_f2[\"F2 projection\"], color=\"black\"\n    )\n    ax[\"a\"].axis(False)\n    ax[\"b\"].plot(\n        -proj_f1[\"F1 projection\"], proj_f1[f\"{f1_nuclei} {f1_units}\"], color=\"black\"\n    )\n    ax[\"b\"].axis(False)\n\n    # Set axis labels with LaTeX formatting and non-italicized letters and position\n    ax[\"A\"].set_xlabel(f\"$^{{{number_y}}}\\\\mathrm{{{nucleus_y}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].set_ylabel(f\"$^{{{number_x}}}\\\\mathrm{{{nucleus_x}}}$ (ppm)\", fontsize=13)\n    ax[\"A\"].yaxis.set_label_position(\"right\")\n    ax[\"A\"].yaxis.tick_right()\n    ax[\"A\"].tick_params(axis=\"x\", labelsize=12)\n    ax[\"A\"].tick_params(axis=\"y\", labelsize=12)\n\n    # Set axis limits if provided\n    if xlim:\n        ax[\"A\"].set_xlim(xlim)\n        ax[\"a\"].set_xlim(xlim)\n    if ylim:\n        ax[\"A\"].set_ylim(ylim)\n        ax[\"b\"].set_ylim(ylim)\n\n    if save:\n        if filename:\n            full_filename = filename + \".\" + format\n        else:\n            full_filename = \"2d_nmr_spectrum.\" + format\n        plt.savefig(\n            full_filename, format=format, dpi=300, bbox_inches=\"tight\", pad_inches=0.1\n        )\n        return None\n    elif return_fig:\n        return ax\n    else:\n        plt.show()\n        return None\n</code></pre>"},{"location":"reference/spinplots/utils.html","title":"utils","text":""},{"location":"reference/spinplots/utils.html#spinplots.utils.calculate_projections","title":"calculate_projections","text":"<pre><code>calculate_projections(data, export=False, filename=None)\n</code></pre> <p>Calculate F1 and F2 projections from a DataFrame or a CSV file.</p> <p>Parameters: data (pd.DataFrame or str): DataFrame or path to a CSV file. export (bool): If True, export the projections to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'projections_f1.csv' and 'projections_f2.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the F1 and F2 projections.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def calculate_projections(data, export=False, filename=None):\n    \"\"\"\n    Calculate F1 and F2 projections from a DataFrame or a CSV file.\n\n    Parameters:\n    data (pd.DataFrame or str): DataFrame or path to a CSV file.\n    export (bool): If True, export the projections to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is 'projections_f1.csv'\n    and 'projections_f2.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the F1 and F2 projections.\n    \"\"\"\n    if isinstance(data, str):\n        df_nmr = pd.read_csv(data)\n    elif isinstance(data, pd.DataFrame):\n        df_nmr = data\n    else:\n        raise ValueError(\"Data must be a DataFrame or a path to a CSV file.\")\n\n    cols = df_nmr.columns\n    f1_nuclei, f1_units = cols[0].split()\n    f2_nuclei, f2_units = cols[1].split()\n    data = (\n        df_nmr[\"intensity\"]\n        .to_numpy()\n        .reshape(len(df_nmr[cols[0]].unique()), len(df_nmr[cols[1]].unique()))\n    )\n\n    f1_proj = np.max(data, axis=1)\n    f2_proj = np.max(data, axis=0)\n\n    # Define df_pos that might have different sizes\n    df_f1 = pd.DataFrame(\n        {\n            f\"{f1_nuclei} {f1_units}\": df_nmr[cols[0]].unique(),\n            \"F1 projection\": f1_proj,\n        }\n    )\n\n    df_f2 = pd.DataFrame(\n        {\n            f\"{f2_nuclei} {f2_units}\": df_nmr[cols[1]].unique(),\n            \"F2 projection\": f2_proj,\n        }\n    )\n\n    if export:\n        if filename is None:\n            filename = \"projections\"\n        df_f1.to_csv(f\"{filename}_f1.csv\", index=False)\n        df_f2.to_csv(f\"{filename}_f2.csv\", index=False)\n    elif not export:\n        return df_f1, df_f2\n\n    return None, None\n</code></pre>"},{"location":"reference/spinplots/utils.html#spinplots.utils.nmr_df","title":"nmr_df","text":"<pre><code>nmr_df(data_path, hz=False, export=False, filename=None)\n</code></pre> <p>Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.</p> <p>Parameters: data_path (str): Path to the NMR data. hz (bool): If True, use Hz scale instead of ppm scale. Default is False. export (bool): If True, export the DataFrame to a CSV file. Default is False. filename (str): Name of the exported CSV file. Default is 'nmr_data.csv'.</p> <p>Returns: pd.DataFrame: DataFrame containing the NMR data.</p> Source code in <code>spinplots/utils.py</code> <pre><code>def nmr_df(data_path, hz=False, export=False, filename=None):\n    \"\"\"\n    Reads Bruker's NMR 1D and 2D data and converts it into a pandas DataFrame.\n\n    Parameters:\n    data_path (str): Path to the NMR data.\n    hz (bool): If True, use Hz scale instead of ppm scale. Default is False.\n    export (bool): If True, export the DataFrame to a CSV file. Default is False.\n    filename (str): Name of the exported CSV file. Default is\n    'nmr_data.csv'.\n\n    Returns:\n    pd.DataFrame: DataFrame containing the NMR data.\n    \"\"\"\n    dic, data = ng.bruker.read_pdata(data_path)\n    udic = ng.bruker.guess_udic(dic, data)\n    ndim = udic[\"ndim\"]\n\n    if ndim == 1:\n        nuclei = udic[0][\"label\"]\n        uc = ng.fileiobase.uc_from_udic(udic, dim=0)\n        ppm = uc.ppm_scale()\n        hz = uc.hz_scale()\n        ndata = data / np.max(data)\n        df_nmr = pd.DataFrame(\n            {\n                \"hz\": hz,\n                \"ppm\": ppm,\n                \"intensity\": data,\n                \"norm_intensity\": ndata,\n                \"nuclei\": nuclei,\n            }\n        )\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    elif ndim == 2:\n        nuclei = [udic[0][\"label\"], udic[1][\"label\"]]\n        uc_f1 = ng.fileiobase.uc_from_udic(udic, dim=0)\n        uc_f2 = ng.fileiobase.uc_from_udic(udic, dim=1)\n        ppm_f1 = uc_f1.ppm_scale()\n        ppm_f2 = uc_f2.ppm_scale()\n        hz_f1 = uc_f1.hz_scale()\n        hz_f2 = uc_f2.hz_scale()\n\n        if hz:\n            F1_hz, F2_hz = np.meshgrid(hz_f1, hz_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} hz\": F1_hz.flatten(),\n                    f\"{nuclei[1]} hz\": F2_hz.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        else:\n            F1_ppm, F2_ppm = np.meshgrid(ppm_f1, ppm_f2, indexing=\"ij\")\n            df_nmr = pd.DataFrame(\n                {\n                    f\"{nuclei[0]} ppm\": F1_ppm.flatten(),\n                    f\"{nuclei[1]} ppm\": F2_ppm.flatten(),\n                    \"intensity\": data.flatten(),\n                }\n            )\n\n        df_nmr.attrs[\"nmr_dim\"] = ndim\n    else:\n        raise ValueError(\"Only 1D and 2D NMR data are supported.\")\n\n    if export:\n        if filename is None:\n            filename = \"nmr_data.csv\"\n        df_nmr.to_csv(filename, index=False)\n        return None\n    elif not export:\n        return df_nmr\n    return None\n</code></pre>"},{"location":"user_guide/easy_plots.html","title":"Easy plots","text":"<p>The current version of <code>SpinPlots</code> only works with processed Bruker data. If you\u2019re dealing with unprocessed data or using data from a different brand, we recommend using NMRglue instead. Also, if you want more control over the looks of your plot, <code>SpinPlots</code> might feel a bit limited since it mostly sticks to the default matplotlib style for now.</p> <p>For this tutorial a series of <sup>13</sup>C,<sup>15</sup>N-labelled Tyrosine and <sup>13</sup>C,<sup>15</sup>N labelled Glycine spectra are used to show the implementation of <code>SpinPlots</code>.</p> <pre><code>from spinplots.plot import bruker1d, bruker1d_grid, bruker2d\n</code></pre> <p>The easiest way to plot a spectrum is as follows :</p> <pre><code>bruker1d(['../../data/1D/20/pdata/1'], xlim=(200, -10))\n\n# Load a simple 1D spectrum of Tyrosine acquired at 9.4T using a MAS rate of 10kHz \n</code></pre> <p><code>SpinPlots</code> uses Matplotlib's standard style by default. If you want to customize the appearance of your spectra, you can use the option <code>return_fig=True</code>. This allows you to return the figure object and modify it as needed before displaying or saving it.</p> <pre><code>fig, ax = bruker1d(['../../data/1D/8/pdata/1'], return_fig=True)\n\nax.set_title('Sample')\nax.set_xlim(200, 90)\nax.lines[0].set_color('red')\nax.lines[0].set_linewidth(2)\nax.lines[0].set_linestyle('--')\nfig.savefig('../../data/1D/modified.png')\n</code></pre> <p>The <code>bruker1d</code> function has a bunch of useful features beyond just making a simple plot. Some of the key ones include:</p> <ul> <li>Plotting several plots together</li> <li>Plot with/without frame</li> <li>Labelling of spectra</li> <li>Normalization of data</li> <li>Select colors for each spectrum using matplotlib's colors</li> <li>Saving the plot directly to a file</li> </ul> <p>Here\u2019s an example that highlights most of these features:</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + '8/pdata/1', path + '12/pdata/1', path + '33/pdata/1', path + '39/pdata/1'],\n              labels=['Sample A', 'Sample B', 'Sample C', 'Sample D'],\n              color=['brown', 'teal', 'skyblue', 'sandybrown'],\n              xlim=(250, -20),\n              frame=False,\n              normalized=False,\n              save=True,\n              filename='../../data/1D/overlapped',\n              format='png')\n</code></pre> <p>You can also opt by stacking the plots, using the <code>stacked</code> keyword, as shown below:</p> <pre><code>path = '../../data/1D/'\nbruker1d([path + '8/pdata/1', path + '12/pdata/1', path + '33/pdata/1', path + '39/pdata/1'],\n              labels=['Sample A', 'Sample B', 'Sample C', 'Sample D'],\n              xlim=(250, -20),\n              frame=False,\n              normalized=True,\n              stacked=True,\n              save=True,\n              filename='../../data/1D/stacked',\n              format='png')\n</code></pre> <p>The <code>bruker1d_grid</code> function works similarly to <code>bruker1d</code>, but instead of overlapping the spectra, it lets you arrange them in a grid (subplots).</p> <p>Here\u2019s an example of how it works:</p> <pre><code>path = '../../data/1D/'\nbruker1d_grid([path + '8/pdata/1', path + '12/pdata/1', path + '33/pdata/1', path + '39/pdata/1'],\n                labels=['Sample A', 'Sample B', 'Sample C', 'Sample D'],\n                xlim=(250, -20),\n                subplot_dims=(2, 2),\n                frame=False,\n                normalized=True,\n                save=True,\n                filename='../../data/1D/grid',\n                format='png')\n</code></pre> <p>The spectra can be normalized either by the highest intensity using <code>normalized='max'</code> or by the number of scans using <code>normalized='scans'</code>. The spectra below compare the <code>unormalized</code> and <code>normalized</code> version using <code>scans</code> and <code>max</code></p> <pre><code>_, ax1 = bruker1d(['../../data/1D/8/pdata/1'], \n                    return_fig=True, \n                    normalized=False, \n                    frame=True,\n                    xlim=(250, -20))\nax1.set_title('No normalization')\n</code></pre> <pre>\n<code>Text(0.5, 1.0, 'No normalization')</code>\n</pre> <pre><code>_, ax2 = bruker1d(['../../data/1D/8/pdata/1'], \n                    return_fig=True, \n                    normalized='scans', \n                    frame=True,\n                    xlim=(250, -20))\nax2.set_title('Normalized by number of scans')\n</code></pre> <pre>\n<code>Text(0.5, 1.0, 'Normalized by number of scans')</code>\n</pre> <pre><code>_, ax3 = bruker1d(['../../data/1D/8/pdata/1'], \n                    return_fig=True, \n                    normalized='max', \n                    frame=True,\n                    xlim=(250, -20))\nax3.set_title('Normalized by maximum value')\n</code></pre> <pre>\n<code>Text(0.5, 1.0, 'Normalized by maximum value')</code>\n</pre> <p>Lastly, the bruker2d function makes it super easy to plot 2D NMR spectra. You just need to provide a bit more info to customize the plot. Here\u2019s what you can specify: - <code>countour_start</code>: the minimum value for the contour plot - <code>countour_num</code>: how many contour levels you want - <code>countour_factor</code>: the factor between each contour level - <code>cmap</code>: the matplotlib colormap for countour (default is 'black') - <code>xlim</code>: limits for the x-axis, i.e. direct dimension (F2) - <code>ylim</code>: limits for the y-axis, i.e. indirect dimension (F1) - <code>save</code>: whether you want to save the plot - <code>filename</code>: the name to save the plot as - <code>format</code>: the file format to save it</p> <pre><code>bruker2d('../../data/2D/36/pdata/1',\n        contour_start=5e5,\n        contour_num=15,\n        contour_factor=1.2,\n        cmap='viridis',\n        xlim=(180, -10),\n        ylim=(16, -5),\n        save=True,\n        filename='../../data/2D/2d_spectrum',\n        format='png',)\n</code></pre> <p>Some NMR spectra, like double-quantum (DQ) experiments, are often visualized with a diagonal line representing <code>y=2x</code>. You can add this diagonal line for any line of the form <code>y=nx</code> using the keyword <code>diag=n</code>, where <code>n</code> sets the desired quantum order. Here\u2019s an example of a <sup>13</sup>C-<sup>13</sup>C DQ-SQ experiment. The option <code>homo=True</code> is only needed if the y-axis label isn\u2019t displaying correctly, such as when the DQ-SQ is acquired through CPMAS.</p> <pre><code>bruker2d('../../data/2D/16/pdata/1',\n        contour_start=7e6,\n        contour_num=25,\n        contour_factor=1.4,\n        xlim=(185, 15),\n        ylim=(305, 55),\n        diag=2,\n        save=True,\n        homo=True,\n        filename='../../data/2D/dq_sq_spectrum',\n        format='png',)\n</code></pre>"},{"location":"user_guide/easy_plots.html#plot-1d-spectra","title":"Plot 1D spectra","text":""},{"location":"user_guide/easy_plots.html#stacked-1d-spectra","title":"Stacked 1D spectra","text":""},{"location":"user_guide/easy_plots.html#plot-2d-spectra","title":"Plot 2D spectra","text":""},{"location":"user_guide/read_export.html","title":"Read export","text":"<p>The functions in the previous tutorial make plotting pretty automatic, using matplotlib's standard style. But sometimes, you might just want to read the data without immediately plotting it\u2014maybe to style it your own way or to convert it into a different format.</p> <pre><code>from spinplots.plot import bruker1d\nfrom spinplots.utils import nmr_df\nimport matplotlib.pyplot as plt\n</code></pre> <p>In the previous tutorial, we used <code>bruker1d(['../../data/1D/8/pdata/1'], xlim=(250, -20))</code> to create a simple <sup>13</sup>C NMR plot. By adding the option <code>return_fig=True</code>, you can return the figure object, which allows you to further customize the appearance of the spectrum as you like.</p> <pre><code>fig, ax = bruker1d(['../../data/1D/8/pdata/1'], xlim=(250, -20), return_fig=True)\nax.set_title('Customized plot')\nax.set_xlabel('$^{31}$P / ppm') \nax.lines[0].set_color('purple')\nax.lines[0].set_linewidth(2)\nax.lines[0].set_linestyle('-.')\nfig.savefig('../../data/1D/customized_plot.png')\n</code></pre> <p>A different option is to use the <code>nmr_df</code> function from <code>spinplots.utils</code> to get a Pandas DataFrame. This way, you can manipulate the data however you like before plotting.</p> <pre><code>df = nmr_df('../../data/1D/8/pdata/1')\nprint(df)\n</code></pre> <pre>\n<code>                hz         ppm     intensity  norm_intensity nuclei\n0     45312.603793  257.397948  3.428250e+06        0.138226    13C\n1     45306.580587  257.363734  3.387071e+06        0.136565    13C\n2     45300.557381  257.329519  3.342889e+06        0.134784    13C\n3     45294.534174  257.295304  3.294650e+06        0.132839    13C\n4     45288.510968  257.261089  3.243548e+06        0.130778    13C\n...            ...         ...           ...             ...    ...\n8187  -3999.385176  -22.718481  2.074913e+06        0.083660    13C\n8188  -4005.408382  -22.752696  2.093999e+06        0.084429    13C\n8189  -4011.431588  -22.786911  2.114482e+06        0.085255    13C\n8190  -4017.454795  -22.821126  2.133052e+06        0.086004    13C\n8191  -4023.478001  -22.855340  2.149332e+06        0.086660    13C\n\n[8192 rows x 5 columns]\n</code>\n</pre> <pre><code>plt.plot(df['ppm'], df['intensity'], color='green')\nplt.xlim(250, -20)\nplt.xlabel('$^{31}$C (ppm)')\nplt.ylabel('Intensity (a.u.)')\nplt.show()\n</code></pre> <p>Pandas DataFrames can be easily exported to other formats such as <code>.csv</code>. You can do this directly in your code with <code>df.to_csv('exported_data.csv')</code>, or use the <code>bruker2csv</code> function from the terminal for a quick export.</p> <pre><code>bruker2csv ../../data/1D/8/pdata/1 ../../data/1D/exported_data.csv\n</code></pre> <pre>\n<code>Data written to ../../data/1D/exported_data.csv\n</code>\n</pre>"},{"location":"user_guide/read_export.html#read-and-export-data","title":"Read and Export data","text":""},{"location":"user_guide/read_export.html#customize-spinplots","title":"Customize spinplots","text":""},{"location":"user_guide/read_export.html#get-pandas-dataframe","title":"Get Pandas Dataframe","text":""}]}